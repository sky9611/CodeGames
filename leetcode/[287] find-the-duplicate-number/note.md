- ## 分析：
  - 题目限制：
     1. 不能更改原数组（假设数组是只读的）；
     2. 只能使用额外的 O(1) 的空间。
  - 正常思路：
    - 使用哈希表判重，这违反了限制b；
    - 将原始数组排序，排序以后，重复的数相邻，即找到了重复数。若in-place排序则违反了限制1，否则违反限制2；
    - 使用类似「力扣」第 41 题：缺失的第一个正数 （原地哈希）的思路，当两个数发现要放在同一个地方的时候，就发现了这个重复的元素，这违反了限制 1；
- ## 方法一（常规）
  - 时间换空间，二分法 + 抽屉原理
- ## 方法二（快慢指针）
  - 将数组理解为链表，数组的下标就是指向元素的指针，把数组的元素也看作指针
  - ```Java
    int point = 0;
    while(true){
        point = nums[point]; // 等同于 next = next->next; 
    }
    ```
  - 然后用快慢指针做