- ## 思路一（暴力）
  - $O(n^2)$
- ## 方法二
  - 使用变量 $count$ 来保存遍历数组过程中到目前为止遇到的 0 和 1 的相对数量。 遇到 1 的时候， $count$ 变量加 1，遇到 0 的时候 $count$ 变量减 1 。
  - 如果我们在遍历数组的过程汇中遇到了相同的 $count$ 两次，这意味着这两个位置`(i, j]`之间 0 和 1 的数目一样多, `len = j - i`。
  - 如果数组是全 0 或者全 1 的时候， $count$ 值的可以达到 -n 和 n ，所以我们使用一个大小为 2n+1 的数组 arr ，以保存所有出现过的 $count$ 值。
  - 对于 $arr$ 数组中的每个位置，我们记录对应 $count$ 值第一次出现的位置。我们在后面每次遇到相同的 $count$ 值，我们就利用第一次出现的位置和当前位置来计算对应子数组的长度。
  - **注意： 代码中数组下标大于0，所以arr数组需要坐标转换，将[-n, n]转换至[0, 2*n]**
- ## 方法三
  - 与前一个方法类似，但是使用hashmap来储存 $count$ 第一次出现的位置 